# Exp_Prover



## Постановка задачи

Необходимо было разработать инструмент для разбора и анализа логических выражений в исчислении высказываний. В рамках задачи нужно было реализовать функциональность проверки корректности выражений, их разбиения на элементы, а также построения структурного представления.

Для выполнения задачи были созданы два модуля:
- `parser.py` — отвечает за разбор выражений и построение синтаксического дерева.
- `expressions.py` — реализует классы для представления различных типов логических операций и переменных.


---

## Описание файлов

### `parser.py`

Этот файл реализует парсинг строковых логических выражений, их валидацию и построение синтаксического дерева. 

#### Основной класс: `Parser`

Класс `Parser` используется для разбора логических выражений. Основные этапы работы:

1. **Токенизация (метод `tokenize`)**:
   - Преобразует строку выражения в список токенов.
   - Проверяет корректность синтаксиса:
     - Баланс скобок.
     - Отсутствие недопустимых символов.
     - Наличие только допустимых операций (\(!, *, |, +, >, =\)) и переменных (латинские буквы).

2. **Парсинг (методы `parse_*`)**:
   - Построение дерева выражения с учётом приоритета операций:
     - Переменные и скобки — `parse_variable`, `parse_parenthesized`.
     - Отрицание (\(!\)) — `parse_negation`.
     - Конъюнкция (\(*\)) — `parse_conjunction`.
     - Дизъюнкция (\(|\)) — `parse_disjunction`.
     - Исключающее ИЛИ (\(+\)) — `parse_xor`.
     - Импликация (\(>\)) — `parse_implication`.
     - Эквиваленция (\(=\)) — `parse_equivalence`.

3. **Работа с токенами**:
   - `current_token()` — возвращает текущий токен.
   - `consume_token()` — проверяет и перемещает указатель на следующий токен.

Пример использования:
```python
from parser import Parser

expression = "!(A > B) | C"
parser = Parser(expression)
parsed_expression = parser.parse()
print(parsed_expression.to_string())  # Вывод: (!(A > B) | C)
```


### expressions.py

Модуль `expressions.py` содержит реализацию классов для представления логических выражений в виде объектов. Все элементы логических выражений (переменные, операции и их комбинации) представлены в виде иерархии классов, наследуемых от базового класса `Expression`.

#### Базовый класс: `Expression`

Абстрактный класс, от которого наследуются все остальные классы. Определяет интерфейс для работы с выражениями.

- **Метод**:
  - `to_string()` — возвращает строковое представление выражения. Обязательно переопределяется в дочерних классах.

#### Дочерние классы:

1. **`Variable`**  
   Представляет логическую переменную.  

   - **Атрибуты**:
     - `name` — имя переменной (например, "A").  
   - **Метод**:
     - `to_string()` — возвращает имя переменной.

2. **`Negation`**  
   Представляет логическую операцию отрицания (\(!\)).  

   - **Атрибуты**:
     - `operand` — выражение, к которому применяется отрицание.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `!<операнд>`.

3. **`Conjunction`**  
   Представляет логическую операцию "И" (\(*\)).  

   - **Атрибуты**:
     - `left` — левый операнд.  
     - `right` — правый операнд.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `(<левый операнд> * <правый операнд>)`.

4. **`Disjunction`**  
   Представляет логическую операцию "ИЛИ" (\(|\)).  

   - **Атрибуты**:
     - `left` — левый операнд.  
     - `right` — правый операнд.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `(<левый операнд> | <правый операнд>)`.

5. **`ExclusiveOr`**  
   Представляет логическую операцию "Исключающее ИЛИ" (\(+\)).  

   - **Атрибуты**:
     - `left` — левый операнд.  
     - `right` — правый операнд.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `(<левый операнд> + <правый операнд>)`.

6. **`Implication`**  
   Представляет логическую операцию импликации (\(>\)).  

   - **Атрибуты**:
     - `left` — левый операнд.  
     - `right` — правый операнд.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `(<левый операнд> > <правый операнд>)`.

7. **`Equivalence`**  
   Представляет логическую операцию эквиваленции (\(=\)).  

   - **Атрибуты**:
     - `left` — левый операнд.  
     - `right` — правый операнд.  
   - **Метод**:
     - `to_string()` — возвращает строку вида `(<левый операнд> = <правый операнд>)`.

---

### Пример использования

```python
from expressions import Variable, Negation, Conjunction

# Создание переменных
A = Variable("A")
B = Variable("B")

# Создание выражения: A * !B
expression = Conjunction(A, Negation(B))

# Вывод строкового представления выражения
print(expression.to_string())  # Вывод: (A * !B)
```
### Задача 1

Теорема о дедукции. Из множества посылок выводится импликация A → B
тогда и только тогда, когда при добавлении A к списку посылок выводится B. Иначе
говоря, Γ ` A → B ⇔ Γ ∪ {A} ` B. В нашей реализации мы смогли доказать только аксиому 11
Основной алгоритм доказательства реализован в методе prove() класса Proof. Он выполняет следующие шаги:

1. **`Разбиение импликаций`**  
   метод decompose_implications() ищет импликации в целевой формуле и пытается перевести их в более простые части. Когда находим импликацию, например A→B, мы добавляем гипотезу A в контекст. Если цель B уже присутствует в контексте, доказательство завершено.

2. **`Добавление гипотез в контекст`**  
   метод add_to_context() добавляет гипотезу в контекст и фиксирует шаги доказательства.

3. **`Проверка цели`**  
   метод check_goal() проверяет, совпадает ли цель с какой-либо гипотезой в контексте.

4. **`Применение правил вывода`**  
   если цель представляет собой импликацию A→B, то из гипотезы A можно вывести B с помощью Модуса поненс. Для этого мы проверяем, содержится ли гипотеза A в контексте. Если она есть, то цель B может быть выведена.
